%------------------------------------------------------%
%- 実装
%------------------------------------------------------%

\section{開発環境}
\subsection{Javaの利用}
今回の開発では実行が高速かつ，オブジェクト指向が今回開発する人工知能フレームワークに適していると
判断したためJavaを用いて開発を行った．\\
また，当研究室に所属する学生はJavaの開発に慣れており，学習コストが低いため採用した．\\

\subsection{Mavenフレームワーク}
Unityとの通信を行うためMavenフレームワークを用いて開発を行った．\\
なおかつ，ライブラリのバージョン管理をソースコードで行えるため，引き継ぐ際の学習コストが低いことが
利点である．\\

%------------------------------------------------------%
%インプットコントローラー
%------------------------------------------------------%
\section{解析部分の実装}
\subsection{解析コントローラー}
この解析コントローラーではすべての解析を行う分野を管理するクラスであり，
解析話題別に解析アルゴリズムを保持する解析知能ハブを作るためにInputControllerを作成した，
それに実装した主要なメソッドなどを以下の\tabref{InputController}に示す．\\

\begin{table}[tbh]
	\caption{実装した主要メソッド} \label{tab:InputController}
	\begin{center}
		\begin{tabular}[htb]{c|c}
		\hline
		コンストラクタ & 各解析知能ハブを登録する \\
		\hline
		InputData & 入力があった時に各解析知能ハブへデータを渡す \\
		\hline
		\end{tabular}
	\end{center}
\end{table}


\tabref{InputController}のコンストラクタでは各解析分野を登録する処理を行う．\\
その部分のソースコードを以下の\srcref{inCnt}に示す．

\srcPst{Java}{inCnt.java}{inCnt}{新しい解析分野を登録する際のソースコード}

このコンストラクタに登録された解析分野は入力があった時に呼び出され，あらかじめ抽象クラスで定義された
適切なメソッドの中のアルゴリズムを記述することで解析を行うことができる．
\\


\tabref{InputController}のInputDataメソッドではユーザーから入力があった時に入力された情報
を各解析分野の実装済みクラスに値を渡すことができる．\\

%------------------------------------------------------%
%親の抽象クラス
%------------------------------------------------------%

\subsection{解析知能ハブ}
初めに解析知能ハブの例を挙げると，感情解析知能ハブや話題解析知能ハブに当たるものであり，
各ハブはそれぞれ様々な解析アルゴリズムを所持している．\\

解析する話題別にアルゴリズムを保持するためにAbstract Mode（以下親抽象クラス）という抽象クラスを
実装した．\\

親抽象クラスには解析する情報ごとにプログラムを保持するための機構が全て記述されており，
この親抽象クラスに実装した主要なメソッドなどを次の\tabref{Abstract Mode}に示す．

\begin{table}[tbh]
	\caption{Abstract Modeに実装した主要メソッド} \label{tab:Abstract Mode}
	\begin{center}
		\begin{tabular}[htb]{c|c}
		\hline
		init & 初期化を行うメソッド \\ \hline
		getAnalyzeParts　& 解析アルゴリズムを選択するメソッド \\ \hline
		analyzeChat & 入力があった際に解析を行わせるメソッド \\ \hline
		\end{tabular}
	\end{center}
\end{table}


\tabref{Abstract Mode}のinitメソッドでは各解析アルゴリズムがもっている話題分野に登録されて
いる単語をGoogle検索にかけて，その検索結果の頻出単語を取得している．
\\
\tabref{Abstract Mode}のgetAnalyzePartsメソッドでは実際に解析を行うアルゴリズムを生成された
頻出単語をもとに決めるメソッドである．
\\
具体的には各解析アルゴリズムごとに生成された頻出単語票のHashMapの単語表とユーザーが入力した文章を
比較して，もっとも似ている頻出単語表を持つ解析アルゴリズムが解析を行うという実装になっている．
\\



%------------------------------------------------------%
%子の抽象クラス
%------------------------------------------------------%

\subsection{解析アルゴリズムの解析知能ハブへの追加}
この人工知能利用フレームワークの解析アルゴリズムを簡単に実装する構成について説明する．\\

簡単にハブに対してアルゴリズムを追加実装するために，
実際に解析アルゴリズムを実装する際に用いる，抽象クラス「Abstract Mode Parts」
(以下，子抽象クラス)を実装した．\\

この子抽象クラスには親抽象クラスであるAbstract Modeを実装したクラスから解析する際に呼び出されるメソッドや
データベースなどとの連携をが記述されているため，アルゴリズムを試したい場合これらの部分については追記
する必要がない点がメリットである．\\

以下の\tabref{Abstract Mode Parts}に実際に解析を行う解析知能を作るために必要な抽象クラスである
Abstract Mode Partsに実装した主要なメソッドなどを示す．
\begin{table}[tbh]
	\caption{Abstract Modeの実装} \label{tab:Abstract Mode Parts}
	\begin{center}
		\begin{tabular}[htb]{c|c}
		\hline
		クラス変数 & 保存を行うための変数が定義されている \\ \hline
		コンストラクタ　& アルゴリズムの分野を記述する場所 \\ \hline
		ChatAnalyze & アルゴリズムを記述する部分 \\ \hline
		saveData & 解析結果を保存 \\ \hline
		\end{tabular}
	\end{center}
\end{table}

\tabref{Abstract Mode Parts}のクラス変数は解析した情報を保存するための変数であり，
解析結果をクラス変数に入れることで処理が終わった後に適切な形式でデータベースに保存される．
\\

\tabref{Abstract Mode Parts}のコンストラクタは，その解析アルゴリズムの分野について記述する
必要性がる，具体的に言うとaboutという変数に話題の名前を入れる必要があり，
また，そうすることで同じ話題をユーザーが話した時にそのアルゴリズムが選択されるという構造が実装される．
\\
その部分のソースコードを以下の\srcref{about}に示します．

\srcPst{Java}{about.java}{about}{コンストラクタで話題を設定するソースコード}

\srcref{about}は料理に関する話題を解析するプログラムのコンストラクタをソースコードから
抜粋したものですが，ここで1行目のプログラムを記述する．
\\

\tabref{Abstract Mode Parts}のChatAnalyzeは，実際に解析アルゴリズムを書く部分です．\\
ここで入力された内容がString型で引数として渡されてくるので，その内容を用いて解析を行う．\\
解析した情報はあらかじめ定義してあるクラス変数に保存することで，
自動でデータベースに格納されるようになっている．

\srcPst{Java}{anaAlgo.java}{anaAlgo}{解析アルゴリズムを記述するメソッドのソースコード}
\srcref{anaAlgo}は解析を行うアルゴリズムを記述するメソッドのみを抜粋したもので，
ここでデータベースに保存する情報を解析し，解析した情報を変数に格納するプログラムを記述する．
\\

\tabref{Abstract Mode Parts}のsaveDataは全ての解析が終わった後に呼び出され，変数の中に値
が入っていた場合のみその内容をデータベースにそのクラス名＋データ型の名前で保存する．

最後にこの抽象クラスを拡張して作成したクラスは親クラスであるAbstract Modeを実装した，
感情解析知能ハブなどの親抽象クラスを実装したクラスのコンストラクタに登録する必要があり，
登録することでアルゴリズムの追加が完了する．\\

%------------------------------------------------------%
%現在実装しているアルゴリズム
%------------------------------------------------------%
\subsection{現在実装している解析アルゴリズム}
現在実装している解析プログラムは2種類あり，感情の解析と話題の解析である．
\\

話題の解析に関しては，例えばゲームの話題解析知能を作った場合，さらに細かい何のゲームかということを
解析することを目的に作成した．
\\
%------------------------------------------------------%
1つ目に感情の解析を行うアルゴリズムの実装について説明する．
\\

感情の解析を行うプログラムは親抽象クラスである感情解析知能ハブに所属する解析知能の1つで，現在感情の
解析を行うプログラムはこの1つなため，必ずこのアルゴリズムがデフォルト解析アルゴリズムとして，
選ばれるようになっている．
\\

具体的な解析を行うアルゴリズムに関しては「哀れ」「恥」「怒り」「嫌」「怖い」「驚き」「好き」「高ぶり」「安らか」「喜び」
の10種類の感情に分類して感情の解析を行なっている．
\\

このそれぞれの感情にはその感情に対応する単語が付いており，入力した文章の中にその単語があった時にその感情値
に1を加えて数字で表現する仕組みになっています．
\\
%------------------------------------------------------%
2つ目の話題を解析する知能では料理とゲームに関する話題を解析するプログラムが実装してあり，
料理の分野では「作る」「食べる」「片付ける」の3つの話題にさらに細かく解析する仕組みがあります．
\\
また，ゲームの分野では「戦闘」「負け」「勝利」の3つの話題にさらに細かく解析する仕組みを実装しています．
\\

%------------------------------------------------------%
%データベース実装
%------------------------------------------------------%

\section{データベースの実装}
\subsection{全ての解析情報を保存する機構}
まず初めにデータベースは独自実装したデータベースクラスを用いて実現した．
\\
データベースの実装では様々な解析情報を保存する必要があるため，複数の変数型に対応するために，HashMap
のキーをStringにし，保存する値であるvalueをObject型に指定した．
\\
このデータベースクラスにはデータを保存するためのメソッドが用意されており，以下にソースコードを示する．
\\
\srcPst{Java}{dbIn.java}{dbIn}{データベースの解析結果を保存するメソッド}

\srcref{dbIn}のメソッドsetDataに対して値を保存する際は解析アルゴリズムの子抽象クラスを実装する
際には記述する必要がなく，
子の抽象クラスの中であらかじめ定義されている変数に値を保存することで，親クラスがsaveDataメソッド
を呼び出し，saveDataメソッドにはこのデータベースクラスのsetDataに対してクラス名と値を送るように
記述してあるため，解析結果のデータを保存することが可能となっている．
\\
\subsection{解析した情報を取得する機構}
解析した情報を取得する際はこのデータベースクラスのgetDataメソッドを呼び出す．
\\
以下の\srcref{dbOut}にgetDataメソッドのソースコードを示す．
\srcPst{Java}{dbOut.java}{dbOut}{データベースの解析結果をするメソッド}

\srcref{dbOut}の2行目を見るとデータを取得する際にString型の鍵が必要である．
\\
このString型の鍵はデータベースの中にあるデータを保存しているHashMapの鍵を示しており，取得したい
情報の鍵をshowDataというメソッドを用いてデータベースの中身を見ることで調べ，その値を指定して取り出す．

%------------------------------------------------------%
%OutputController
%------------------------------------------------------%

\section{出力を行う部分の実装}
Unityへ返答するための情報を作成する部分の実装について説明する．
\\
\subsection{出力コントローラー}
出力する情報をまとめ，JSON形式などを形成する出力コントローラーについて解説する．\\
まず初めに出力コントローラーに実装した主要なメソッド一覧を以下の\tabref{OutputController}に示す．\\

\begin{table}[tbh]
	\caption{実装した主要なメソッド} \label{tab:OutputController}
	\begin{center}
		\begin{tabular}[htb]{c|c}
		\hline
		コンストラクタ & 各出力知能ハブを登録する \\
		\hline
		getJson & Unityへ出力情報を送るときに呼ばれるメソッド \\
		\hline
		getTimeAction & キャラクターが自発的に発言する際に用いられるメソッド \\
		\hline
		\end{tabular}
	\end{center}
\end{table}

\tabref{OutputController}のコンストラクタの部分では，各出力知能ハブを登録し，
\\
登録された出力知能ハブはgetJsonメソッドが呼ばれたときに出力内容を作成するようになっている．
\\
\tabref{OutputController}のgetJsonメソッドではUnityから入力があった際に返答を行い，
そのときに呼ばれるメソッドであり，あらかじめ登録されている出力知能ハブの出力を作成するメソッドを呼び出す様になっている．
\\
\tabref{OutputController}のgetTimeActionメソッドでは時間経過に応じてキャラクターが発言する
設定を有効にしているときに呼び出されるメソッドであり，このメソッドが呼ばれると各出力知能ハブの
自発的に発言する際に用いるメソッドを呼び出す．
\\

%------------------------------------------------------%
%出力知能はぶ Abstract_Mode
%------------------------------------------------------%


\subsection{出力知能ハブ}
出力する動作や返答内容といった出力情報別にアルゴリズムを保持する機構について解説したいと思う．\\

この機構も情報解析の時と同じ仕組みで構成されており，この出力の情報別に保持する機構についても
Abstact Modeという親抽象クラスが作成されているので，その抽象クラスを実装することで出力知能ハブであり，
返答知能ハブや動作選択知能ハブを作成することができる．
\\
以下の\tabref{abstractmode}に出力知能ハブを作成するために必要な抽象クラスである
Abstract Modeの主要メソッドを示す．\\

\begin{table}[tbh]
	\caption{実装した主要なメソッド} \label{tab:abstractmode}
	\begin{center}
		\begin{tabular}[htb]{c|c}
		\hline
		init & 初期化 \\
		\hline
		getOutput & 返答内容の作成 \\
		\hline
		getTimerAction & キャラクターが自発的に発言する際に用いられるメソッド \\
		\hline
		\end{tabular}
	\end{center}
\end{table}

\tabref{abstractmode}のinitメソッドでは初期設定を行っており，Googleの検索結果データベースを
最新の情報に更新をするなどの処理を行っている．
\\
\tabref{abstractmode}のgetOutputメソッドではUnityにユーザーが話しかけてきたときに返答内容を
作成するアルゴリズムから出力内容を取得して，その内容を返すメソッドになっており，
また，返答するアルゴリズムを選択する機構もこの部分にある．
\\
その選択は以下のようにHashMapを用いてユーザーが発言した内容から作成した頻出単語票であるHashMapと各解析を実際に行う
アルゴリズムが持っている話題をもとに作成した頻出単語票であるHashMapを比較して，もっとも頻出単語票が似ている
ものを選ぶという仕組みになっています．\\

\srcPst{Java}{getOutput.java}{getOutput}{getOutput.javaのソースコード}

まず初めに，\srcref{getOutput}の8,9行目で最新の発言情報を取得し，10行めで発言内容をGoogleAPIに
渡すことで頻出単語票を作成する．
\\
次にあらかじめ作成してある各解析アルゴリズムごとの話題単語の頻出単語票とGoogleAPIを用いて取得した頻出単語票を
11行めから25行めにかけて比較して，一番最適な解析アルゴリズムを選択している．
\\
最後に45行目にて選択された解析アルゴリズムに解析を行わせ，解析結果をそのまま返している．\\


\tabref{abstractmode}のgetTimerActionメソッドは時間経過に応じて反応するときに呼び出され，
実際に出力内容を作成するアルゴリズムに対して，自発的に発言する際の出力内容を作成させ，取得する．\\



\subsection{出力アルゴリズムの出力知能ハブへの追加}
実際に出力情報を作成するためのアルゴリズムを記述するプログラムを簡単に出力知能ハブへ追加するために
出力専用のAbstract Mode Partsという抽象クラスを作成した．\\

その抽象クラスを用いることで3行プログラムを書くだけで新しいアルゴリズムを追加できるようになっている．\\

それではまず初めに，その抽象クラスに実装した以下の\tabref{parts}に示した主要なメソッドについて解説します．\\

\begin{table}[tbh]
	\caption{実装した主要なメソッド} \label{tab:parts}
	\begin{center}
		\begin{tabular}[htb]{c|c}
		\hline
		コンストラクタ & 担当分野の設定 \\
		\hline
		Action & 返答アルゴリズムの \\
		\hline
		TimeAction & キャラクターが自発的に発言する際に用いられるメソッド \\
		\hline
		dataRefresh & 常にデータベースを最新に保つためのメソッド \\
		\hline
		\end{tabular}
	\end{center}
\end{table}

\tabref{parts}のコンストラクタでは出力を行う際に担当する分野や話題について記述する部分である，解析の
時と同じように変数aboutに対して適切な担当する話題名を入れることで，GoogleAPIを用いて
その話題名に関する頻出単語票が自動で生成されます，その生成された頻出単語表は先ほど説明したアルゴリズムの
選定に利用される．\\

以下の\srcref{aisatu}に挨拶の分野を指定する場合のプログラムの例を示す. 
\\
\srcPst{Java}{aisatu.java}{aisatu}{話題を指定する際のサンプルソースコード}

\srcref{aisatu}では話題を挨拶に指定しており，ユーザーが挨拶と関係のある単語を発話した時にこのアルゴリズムが
選択され，実際に返答内容を作成する．
\\
\subsection{現在実装している出力アルゴリズム}\label{sec:back}
現在実装している出力知能ハブは2つあり，会話を行う知能ハブと動作選択を行う知能ハブの2種類である．
\\
会話を行う知能ハブには2つのアルゴリズムが搭載されており，料理とゲームの話題に関するアルゴリズムを実装した．
\\
料理出力のアルゴリズムでは，解析した時に取得した作る，食べる，片付けるの状態を用いて，返答を行う．
\\
また，ゲームのアルゴリズムでは戦闘，負け，勝利の状態を解析しているのでそれを用いて返答を行っている．
\\

次に動作を選択するアルゴリズムでは共同開発の鈴木さんのデータベースから動作一覧，その1つ1つの動作に関係する単語，
その関係する単語をGoogleAPIをもちいて頻出単語表を作ったものを取得する．
\\

動作を選択するアルゴリズムはその動作に関連付けられている頻出単語表と，ユーザーの発言内容から作成した
頻出単語表を比較して，最も関連性のあるモーションを選択するようになっている．\\

その具体的なアルゴリズムや通信に関しては\ref{sec:motion}に記述する．\\


%------------------------------------------------------%
%Unityとの通信に関して
%------------------------------------------------------%




\section{Unityとの通信の実装}
\subsection{通信方式}
Unityとの通信にはWebSocketを用いており，双方向任意のタイミングでの情報の送受信が可能となっている．\\
Unityとの情報の送受信を行うために人工知能利用フレームワークの中に送受信を行うためのクラスである，
NewWSEndpointを実装した．\\

以下の\srcref{endpoint}にソースコードを示す．\\

\srcPst{Java}{endpoint.java}{endpoint}{動作選択アルゴリズムの一部抜粋}




\subsection{Unityからの入力情報の受信}
\srcref{endpoint}のソースコードではUnity（クライアント）が接続を行った時にそのセッションを保存するために
23行目でリストにセッションを保存している．\\

セッションが確立され，受信を行う準備が完了した．\\

Unityからメッセージが来た場合は\srcref{endpoint}の44行目のprocessUploadが呼ばれる．
また33行目には同じく受信するメソッドであるOnMessageというメソッドがありますが，
これはUnity以外の端末からメッセージを受け取った際に呼ばれる．\\

processUploadメソッドではバイト形式で入力情報を受け取るため，47行目にてバイトをString型に変換する必要がある．\\
変換した後は48行目でその値を入力情報の解析を行う解析知能ハブへ渡し，その処理が終わった後の49行目で返答する値を生成，
作成したjson形式の出力情報をもらい51行めで全ての接続クライアントに対して命令を送信している．\\



最後にこれ以上通信を行わない場合は\srcref{endpoint}の27行目で，セッションが切断された時に
リストから削除する処理を行っている．\\


\subsection{Unityへの命令の送信}
\srcref{endpoint}の51行目で全ての接続クライアントに対して出力知能ハブから得たjson形式の値を
送信している．\\

また，送信する先が全てのクライアントに対して送信することになっていますが，これは人工知能利用フレームワーク
が家庭で利用されることを目標にしているからである．\\

例えばテレビのブラウザでキャラクターと対話，PCの画面でキャラクターと対話，スマホの画面でキャラクターと対話
を行った際に全てのデバイスから同じキャラクターと対話することができるということを実現するために51行目では
全てのクライアントへ対して情報を送信している．\\

%------------------------------------------------------%
%データベースとの通信とモーションデータベースについて
%------------------------------------------------------%

\section{人工知能利用フレームワークに追加したモーションの利用}\label{sec:motion}
\subsection{動作選択アルゴリズムの実装}
先ほど\ref{sec:back}で説明した動作選択を行う際に用いているアルゴリズムについて解説する．\\

そのため，以下に動作を選択する際に用いている動作選択アルゴリズムを一部抜粋したものを示す．

\srcPst{Java}{motion.java}{motion}{動作選択アルゴリズムの一部抜粋}

まず初めに，\srcref{motion}の3行目に動作選択が行われる際に呼び出されるActionメソッドが記述されています，
このメソッドでは8行目に記述されたメソッドmatchを呼び出し，その中で適切なモーションを選択している．\\

\srcref{motion}のmatchメソッドでは15行目から17行目にかけてデータベースを管理するコントローラーから
データベースの情報を取得しています，このコントローラーがサーバー上のMongoDBからモーションデータなどの
情報を取得している．
\\
また，このコントローラの実装に関しては共同開発の鈴木さんの論文を参照するとこのコントローラーからデータベース
への接続を行なっていることがわかる．
\\

次に実際にどの動作を実行するかを判定しているアルゴリズムですが\srcref{motion}の22行目から39行目を
みてください，そこではユーザーが発言した内容から作成した頻出単語表とデータベースの中にあるモーションごと
に関連付けられている頻出単語表を比較している．\\

その2つの頻出単語表の比較結果の中で一番同じ単語が多く出現した動作が選択され，40行目でその動作名が
返される仕組みとなっている．\\


%------------------------------------------------------%
%GoogleAPI
%------------------------------------------------------%


\section{GoogleAPIによる頻出単語表の作成}
今回実装したGoogleAPIではGoogle検索を用いてウェブ上から情報を取得する機能から
kuromojiを用いて形態素解析を行わせる機能，頻出単語表を作成する機能と3つの機能から成り立っている．
\\
\subsection{形態素解析による検索ワードの作成}
ユーザーが入力した情報をGoogle検索を用いて検索し，どのような分野の単語なのかということを調べるにあたり，
その検索する際のキーワードというものは非常に大切である．\\

そのためJavaの形態素解析器であるkuromoji\cite{gitkuromoji}を用いて形態素解析を行い，
適切な検索ワードを指定できるようにmwSoft blog\cite{kuromoji}を参照，参考にしつつ実装を行った．\\

具体的には，kuromojiには複数のモードがあり，Searchモードを利用することで「日本経済新聞」を
「日本 | 経済 | 新聞」のように検索で利用しやすい形に分解してくれる機能があるのでその機能を用いて
入力を行った情報をそのまま検索するのではなく形態素解析を行ってから検索を行う．\\



\subsection{GoogleAPIを利用して検索結果を取得}
検索をかける際にはHttpClientを用いて検索を行っている，HttpClientはPOST通信を用いてサーバーへ接続を
行い，XML形式で結果を受け取るもので，これを用いることでgoogleの検索結果をそのまま取得することができる．\\
また，この機構を実現するためにmwSoft blog\cite{google}を参考にした．

以下の\srcref{google}に実装を行ったGoogleAPIのソースを一部抜粋したものを記載する．
\srcPst{Java}{google.java}{google}{GoogleAPIの一部抜粋ソースコード}

\srcref{google}の20行めにて検索先のURLを作成しており，googleの検索結果ページのURLを作成し，
情報を取得することでGoogle検索の結果と同等の内容を取得している．\\

\srcref{google}の23行めから37行めにかけて検索キーワードを作成しており，先ほど説明したkuromojiの
検索しやすい単語ごとに区切るSearchモードの機能だけではなく，今回は助詞と助動詞を検索ワードから排除して検索を
行なっている．\\

\srcref{google}の47行めでは実際にウェブサイト上から情報を取得しており，取得した結果を
GoogleSerchResultAnalyzerクラスを用いて解析を行い，リストに格納している．\\



\subsection{検索結果のフィルタリング}
検索結果にはどの単語を検索しても必ず含まれる単語が複数ある．\\
例としては「キャッシュ」といった単語や「類似」という単語である．\\
これらの単語は頻出単語表を作成する上で不要なため，フィルタリングを行っており，実際にフィルタリングを行っているのは
\srcref{google}の84行めから108行めである．
また，84行めから行われているのは記号を取り除く作業であり，頻出単語とはなりえない記号を取り除いている．\\

\subsection{頻出単語表の作成}
頻出単語表を作成するにあたって独自にWordCounterというクラスを実装した．\\

以下にWordCounterから一部抜粋したソースコードを記載する．


\srcPst{Java}{word.java}{word}{WordCounterの一部抜粋ソースコード}

\srcref{word}の7行めに定義されているwordcountというメソッドに対して単語ごとにカウントを行って欲しい
文字列を渡すことで，解析を行うことができる，また引数としてはborderを設定することができ，1回しか出てこない
単語に関してはカウントを行わないという設定を行うことができる．\\

初めにカウントを行うにあたって入力された文章を形態素解析にかける必要がある，実装では
\srcref{word}の11行めにて，kuromojiを用いた形態素解析を行なっている．
\\

次に形態素解析を行った文章に出てくる単語をカウントする部分については\srcref{word}の14行めから24行めにて
行っている．
\\

最後にカウントした結果をHashMap形式にし，41行めでそのHashMapを返していることがわかる．
\\

