%------------------------------------------------------%
%- 構成
%- プログラムが実際どういう関連性があるのかについて少し細かく説明する
%------------------------------------------------------%
知能ハブ\footnote{Unityの入力を受け取り，動作や発言を決める知能を複数集めたもの}の構成を解説する．
構成としては解析，保存，出力及びUnityとの通信，GoogleAPIがある．
全体の構成は\ref{sec:allAr}に示した図と同じ構成である．

%------------------------------------------------------%
\section{入力された情報を解析する機構}
Unityで作成されたキャラクターに対してユーザが発言を行い，解析知能ハブが入力情報を解析する際の機構に
ついて解説する．
以下\figref{analyze_chart}に入力された情報が解析され，解析結果がデータベースに格納されるまでの
構成を示す．

\figPst{100}{analyze_chart}{解析が行われるまでの図}

\figref{analyze_chart}の大まかな流れを解説する．
ユーザーがキャラクターに話しかけると，
その内容をUnity側で受け取り文字列に変換して，解析知能ハブへと送信する．

送信した情報は解析知能ハブで受け取られ，知能ハブは感情解析知能ハブ
\footnote{独自実装を行った感情を解析するためのアルゴリズムを複数持つアルゴリズムのハブ}
や話題解析知能ハブ
\footnote{独自実装を行った話題を解析するためのアルゴリズムを複数持つアルゴリズムのハブ}
などの各解析知能ハブへと渡される．

\figref{analyze_chart}の場合，感情を解析する「感情解析知能ハブ」と話題を解析する「話題解析知能
ハブ」があるため，受け取った情報はこの2つの解析ハブへと渡される．
情報が渡されると各解析ハブはその情報をもとに，登録されている各解析アルゴリズムの中から
もっとも適切な解析アルゴリズムを選択し，実際の解析を行う．

解析された情報は知能ハブ全体で共有されているデータベースへ自動で保存される設計となっており，
その情報は様々な解析クラスや出力を作成するクラスから利用することが可能である．
それでは以下の章で解析知能ハブの中のそれぞれの機能について説明する．

\subsection{解析する情報別にアルゴリズムを保持する機能}
\figref{analyze_chart}を見て分かる通り，入力された情報はそれぞれ入力データを
各解析知能へと渡される．
各解析知能は，その情報を解析するためのアルゴリズムを複数所持しており，
その構図を具体例を用いて表した図を以下の\figref{feel_analyze}に示す．

\figPst{100}{feel_analyze}{感情解析知能ハブとそれに付随する解析アルゴリズム}

\figref{feel_analyze}の感情解析知能ハブは，複数の話題毎に特化した
感情を解析するためのアルゴリズムを所持している．

各感情解析知能ハブや話題解析知能ハブなどはその解析するためのアルゴリズムを保存するために，アルゴリズム型の配列を持っており，
\figref{feel_analyze}の「料理時における感情解析知能」や「ゲームプレイ時における感情解析知能」
などはその配列に含まれている．

解析知能ハブは配列内に，解析アルゴリズムの抽象クラスを実装したものを格納するだけで複数のアルゴリズムを所持し，
適切なアルゴリズムが選択されるように設計されている．

\figref{feel_analyze}の「感情解析知能ハブ」にあたる解析する情報である感情や，話題といった種類
は追加が可能である．
このクラスが継承している「親抽象クラス\footnote{独自実装を行った解析を行う感情や話題
といった種類を増やす時に用いる抽象クラス}」を実装し，解析知能ハブにある親抽象クラスを
保存する配列に作成したクラスを追加することで，新しく解析する情報の種類を増やすことができる．

\subsection{会話の話題別に解析するアルゴリズムを選ぶ機能}
この人工知能ハブでは現在話している話題をもとに，どの解析アルゴリズムを選択するかを判定している．
料理に関する話題をしている際は，料理関連の単語や会話に対応した解析アルゴリズムが選択され
解析を行い，料理関連のアルゴリズムがない場合はその他の解析アルゴリズム
の中でもっとも適した解析アルゴリズムが解析を行う設計になっている．

話題を推定する際にはGoogleAPI\footnote{独自実装を行ったGoogleを用いて検索を行う機能}
を用いており，その詳しい実装は後で記述している．
アルゴリズムの選択方法は，入力された内容を検索にかけて頻出単語表を作成したものと既存の各アルゴリズムに登録された話題から
作成した頻出単語表と比べて，最も似ている頻出単語表をもつ解析アルゴリズムを選択している．

この様な構造を用いることで最適なアルゴリズムが選択されると考えた．
例えば以下の\figref{kuppa_down}「クッパ
	\footnote{クッパ：ゲーム「スーパーマリオブラザーズ」に登場する敵キャラクター}
が落ちた」という入力を行った時には「クッパ　落ちた」というキーワードで検索を行い，その結果から頻出単語表を作成する．

\figPst{100}{kuppa_down}{2015年12月20日現在の「クッパ　落ちた」のGoogle検索結果}

\figref{kuppa_down}の検索結果を見ると，私の期待通りスーパーマリオブラザーズ（以下マリオ）に関係する検索結果を取得
できていることがわかる．
この検索結果に出てくる単語の中から固有名詞だけを取り出し頻出単語表を作成することでマリオに関連のある単語表が完成する．
マリオ専用のアルゴリズムがある場合，同じ工程で「マリオ」の検索結果をもとに頻出単語表が作られる．
今回作成した「マリオ　落ちた」で作成した頻出単語表とアルゴリズム側に設定した話題である「マリオ」の検索結果で作成した
頻出単語表は，「料理」などの他の単語で検索した際の頻出単語表と比較して一番頻出単語が似ているため
マリオの解析アルゴリズムが選択される．

この時マリオに特化したアルゴリズムの他に料理に特化したアルゴリズムも実装されているとする，その状態で
「クッパ\footnote{クッパ：クッパは韓国料理の一種。 スープとご飯を組み合わせた雑炊のような料理}
って美味しいよね」という入力があった場合については次のようになる．

以下の\figref{kuppa_umai}の「クッパ　美味しい」
の検索結果を見て分かる通り，韓国料理のクッパの話題を取得している事がわかる．
同じクッパという単語は出現するが，料理で検索した結果をもとに作成した頻出単語表の方が出現固有名詞が似ているため，
マリオのアルゴリズムが選択される事はなく，料理に特化した感情解析を行うアルゴリズムが選択されるように設計している．

\figPst{100}{kuppa_umai}{2015年12月20日現在の「クッパ　美味しい」のGoogle検索結果}

このようにその場の話題に合わせて適切な解析を行うアルゴリズムが選択されるような構造があることで，より高精度な解析を行うことができる．
この機能がない場合「クッパが落ちた」という文章は，「落ちた」というキーワードから「クッパ」がゲームの敵キャラクターとわからない限りは
マイナスイメージな文と解析される．

「クッパが落ちた」「クッパって美味しいよね」の両方の文章を適切に解析できる，
話題に限らず感情を解析できるアルゴリズムを作成した場合は，
そのアルゴリズムのみを感情解析知能ハブに登録することで確実にそのアルゴリズムが選択されるようにする事もできるような設計とした．

\subsection{解析アルゴリズムを簡単に追加する機構}
解析を行うアルゴリズムを簡単に追加する機構について解説する．
実際に解析を行うアルゴリズムの追加は，予め定義されている子の抽象クラス
\footnote{アルゴリズムを追加する際に用いる抽象クラスであり，アルゴリズム以外の必要な処理が記述されている抽象クラス}
を実装することで
追加することが可能である．
その実装の手順はソースコードの行数に換算すると，アルゴリズムの解析を行う話題の設定，
アルゴリズム自体，親クラスへの登録という最短3行でアルゴリズムを追加することが可能になっている．

\figref{feel_analyze}のゲームプレイ時における感情解析知能を追加したい場合は，子抽象クラスの
話題を設定し，アルゴリズムを実装後，感情解析知能ハブにある抽象クラス型を保持する配列に対して，
作成したアルゴリズムを入れることで実装を完了することができる．

話題や感情などを解析する話題解析知能ハブなどの，親の抽象クラスを実装したものが，
子の抽象クラスを実装したアルゴリズムを複数所持する構図となり，その関係性を\figref{analyze_abs}に示す．

\figPst{80}{analyze_abs}{抽象クラスの関係と抽象クラスの実装例}

\figref{analyze_abs}の通り，親の抽象クラスだけでなく，子の抽象クラスに関しても新たなアルゴリズムを考案した
際には簡単にそのアルゴリズムの実装を行い，感情を解析する
知能ハブや話題を解析する知能ハブに対して特定の話題を持ったアルゴリズムを追加する機構がある．

%------------------------------------------------------%
\newpage
%------------------------------------------------------%

\section{解析結果を保存する機構}
人工知能ハブには解析を行った情報やその他の様々な情報を保存するためのデータベースクラス（以下データベース）が実装
されている．
また，データベースはすべてのクラスで共有で利用できるように，すべての解析知能や出力
を作成する知能の抽象クラスに含まれている．

\subsection{解析情報を保存する機能}
データベースは，解析した情報を保存する機能がある．
情報を保存する際に保存を行うデータ型は複数あるが，解析結果がどのような形式でも保存が可能な様にobject型を利用している．

実際に保存を行う場合は各解析アルゴリズム内に定義済みの変数に対して値を入れるだけで自動で保存が行われ，
保存する際に付けられる名前は明確性と同一名のデータが存在しないように，その解析アルゴリズムの
プログラム名＋データの形式という形で保存される．
この構成により複数の製作者がいる際にデータの衝突が起きない様に設計されている．

例えばMode-Topic-Gameというゲーム話題解析知能が文字列で話題を保存したい場合は，
そのアルゴリズムの中で解析が終わった際に予め定義されている変数に値を入れるだけで良く，
変数に保存した情報はMode-Topic-Game-Stringという名前が自動生成され，データベースへと保存される．

\subsection{解析情報を取得する機能}
解析した情報をデータベースから取得する方法について解説する．

データの取得を行う際にはデータベースオブジェクトの情報取得メソッドに対して先ほどの解析情報の保存
に用いた，名前を指定することでその情報を取得することができる．

取得する際はobject型で取得されるので，取得する際に利用するキー（文字）の最後を見て
その変数の型名にキャストすることで利用出来る．

%------------------------------------------------------%
\newpage
%------------------------------------------------------%

\section{解析情報を元に出力内容を作成する機構}
解析された情報を元にUnityのキャラクターに命令を送信する工程について，
キャラクターと会話をする例を\figref{output}に示し，これを用いて説明する．

\figPst{100}{output}{出力情報を作成するまでの流れ}

\figref{output}を見て分かる通り，出力作成知能ハブにも出力したい情報ごとにアルゴリズムを保持する
機構がある．
\figref{output}の場合は会話を行うための会話知能ハブとキャラクターの動作を
選択するための動作選択知能ハブの2つがある．

それぞれのハブでは入力された情報を元に，解析知能ハブの時と同じように話題を推定し最適なアルゴリズムを選択する．
選択されたアルゴリズムは，それぞれデータベースにある利用したい情報を取得し，返答内容や動作を決定
する．
それぞれのアルゴリズム処理結果は，Unityへの命令形式であるJSON形式にまとめられ
websocket通信を用いてウェブブラウザ上のUnityで開発されたキャラクター(以下キャラクター)へと送信され，キャラクター
が命令を解釈，キャラクターが動作するという流れになっている．

\subsection{返答を行うタイミング}
人工知能ハブが返答や命令を行うことができるタイミングは2種類ある．
1つめは相手から入力があった場合の返答，2つ目が自ら発言する場合に返答する場合である．

相手から入力があった場合の返答は，Unityから情報が送信されてきた時に出力を作成する知能ハブを呼び出
すことで出力内容を作成し，返答を行うものである．

自ら発言を行う場合は実装を行ってあるタイマーを利用して発言を行う．
特定の時間や変数の値，特定の感情値になった際に発言を行うように設定することが可能である．
出力内容作成知能ハブの自発的に発言する内容を作成するメソッドをそのタイミングで呼び出すことで
自発的な発言が可能となっている．

感情値や時間経過，状況の変化があった時にwebsocketを用いてUnityへ任意のタイミングで命令が可能なため，
自発的に発言しているように見せることが可能である．

自ら発言する場合と，返答を行う場合でアルゴリズムが異なることが多いと考え，\figref{analyze_abs}
のアルゴリズムを実装するための子の抽象クラスには返答する際のアルゴリズムと自ら発言する際の
アルゴリズムを書くメソッドがそれぞれ用意されている．

\subsection{会話の話題別に返答アルゴリズムを保持する機能}
返答を行う際も，解析を行うときと同様に話題別に返答アルゴリズムを保持している．
返答アルゴリズムを保持する仕組みに関しても同じく，返答アルゴリズム型の配列を持っており，
その配列内に返答アルゴリズムの抽象クラスを実装したものを格納するだけで，複数の返答アルゴリズムを所持し，
適切なアルゴリズムが選択される．

%------------------------------------------------------%
\newpage
%------------------------------------------------------%
\section{作成した知能をUnityで試す機構}
作成したアルゴリズムをすぐにキャラクターとの対話を可能にする環境の作成に今回は統合開発環境を内蔵し，
複数のプラットホームに対応するゲームエンジンであるUnityを採用した．

このゲームエンジンを用いることで，ウェブブラウザ上で動作するキャラクターを簡単に作成することが
可能である．
ブラウザ上で動作するため，様々なプラットフォームで試すことが可能であり，
ブラウザを搭載していないデバイスの場合でもUnity自体が複数のプラットフォームに
対応しているため，様々な人が開発したアルゴリズムをすぐに試すことが可能になる．

\subsection{UnityWebPlayerでの出力について}
今回作成した人工知能利用フレームワークではUnityWebPlayerを用いてブラウザ上でキャラクターとの
コミュニケーションを取れるように設計した．

\figPst{100}{unity}{Unity Web Playerによるキャラクターの表示画面}

\figref{unity}のようにブラウザを搭載しているPCやmacなどのデバイスならばキャラクターを表示する
ことが可能であり，作成したアルゴリズムをすぐに試すことが可能である．

\subsection{Unityとの連携に利用するWebSocket}
Unityとの通信にはWeb Socketを用いる．
web socketとはウェブサーバーとウェブブラウザとの間の通信のために規定を予定している双方向通信用
の技術規格であり，それを採用した理由としてあげられるのが任意のタイミングでのpush通知が可能な点である．

push通知が可能になることによって，人工知能利用フレームワークから好きなタイミングで命令を送信し，
Unity上のキャラクターを動作させることができる．
Unity側のプログラムとしても命令がきた時にだけキャラクターを動作させ，ユーザーから入力があった時だけサーバへ入力情報を送信
すればよいので，従来のサーバーへ常時アクセスをする方法よりも処理が軽減されるという利点もある．

\subsection{Unityへの送信フォーマットと作成}
\figref{output}の「返答内容をJSON形式にまとめてpush送信する」という部分の解説を行う．
このUnityへの命令の送信は，汎用性の高いJSON形式\footnote{JSON形式：軽量なデータ記述言語の1つ}を用い
て送信を行う．

このJSON形式のデータを実際に作成しているのは\figref{output}の出力知能作成ハブであり，
各それぞれの返答内容作成知能ハブや動作選択知能ハブから受け取った情報をまとめてJSON形式
にし，送信を行っている．

\subsection{Unityからの受信フォーマット}
Unityから情報を受け取る際にもJSON形式を用いており，現在はユーザーが発言した内容を取得している．
JSON形式のデータを解釈する機能も付いているので，Unity側から受け取ることができる情報を随時追加する
ことができる設計となっている．
%------------------------------------------------------%
\newpage
%------------------------------------------------------%
\section{アルゴリズムを選定する際に用いるGoogleAPI}
上記で説明したアルゴリズムを選定する際に用いているGoogleAPIについて解説する．

\subsection{GoogleAPIについて}
この論文内で示すGooogleAPIとは独自に開発したGoogle検索を応用したプログラムであり，
HttpClientを用いてウェブ上からGoogleの検索結果をHttpCleanerで整形し，
その後整形した情報を形態素解析にかけて，固有名詞のみを抽出し，固有名詞とその単語がでてきた回数を
保存するプログラムである．

\subsection{GoogleAPIの有効性}
Googleの検索結果を用いることで，常に最新の検索ワードに関するキーワードが手に入る．
加えて一見「料理」という単語と「ごはん」という単語は文字列だけを比較しても関連性はないように見えるが，
この2つの検索結果の頻出単語表には料理という単語が含まれており単語表を比較することで同じ分野の単語であることを知ることができる．

Google検索を用いているので，例えば「サバの味噌煮」と検索をして，検索結果の文字列から頻出単語表
を作成した際に，一見料理に全く関係のない単語である文字列である「パッド」という単語が入っていることがある．
しかし，料理関連の解析知能がもつ「料理」の検索結果から作成した単語表にも同じく「パッド」という単語は複数回出ており，
料理のアルゴリズムが選択される．

これは同じウェブサイトである，「クックパッド\footnote{献立に困った時，すぐに希望の食材で検索ができる，
また自分の料理ホームページが簡単にもてる，アクセス数・登録レシピ数ともに日本一のレシピサイトである．}」
が表示されることを活用しているからである．