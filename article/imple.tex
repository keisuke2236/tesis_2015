%------------------------------------------------------%
%- 実装
%------------------------------------------------------%
\section{開発環境}
\subsection{Javaの利用}
今回の開発では，実行が高速かつオブジェクト指向が今回開発する人工知能フレームワークに適していると
判断したためJavaを用いて開発を行った．
また，当研究室に所属する学生はJavaの開発に慣れており，学習コストが低いため採用した．

\subsection{Mavenフレームワーク}
Unityとの通信を行うためMavenフレームワークを用いて開発を行った．
ライブラリのバージョン管理をソースコードで行える利点もある．

%------------------------------------------------------%
%インプットコントローラー
%------------------------------------------------------%
\section{解析部分の実装}
\subsection{解析コントローラー}
解析コントローラーでは，「話題解析」や「感情解析」と言った解析を行う分野自体を管理するクラスである．
今回はその解析分野\footnote{解析分野：話題を解析する場合の解析分野は話題であり，感情を解析する場合の解析分野は話題となる．}
別に解析アルゴリズムを保持する，各解析知能ハブ
\footnote{話題解析知能ハブや感情解析知能ハブなどの解析分野別に作成されるアルゴリズムを複数所持するクラス}
を作るためにInputControllerを作成した．
InputControllerに実装した主要なメソッドなどを以下の\tabref{InputController}に示す．

\begin{table}[tbh]
	\caption{実装した主要構成要素} \label{tab:InputController}
	\begin{center}
		\begin{tabular}[htb]{c|c}
		\hline
		コンストラクタ & 各解析知能ハブを登録する \\
		\hline
		InputData & 入力があった時に各解析知能ハブへデータを渡す \\
		\hline
		\end{tabular}
	\end{center}
\end{table}


\tabref{InputController}のコンストラクタでは「感情」や「話題」などの各解析分野を登録する処理を行う．
その部分のソースコードを一部抜粋したものを以下の\srcref{inCnt}に示す．

\srcPst{Java}{inCnt.java}{inCnt}{新しい解析分野を登録する際のソースコードの一部}

\srcref{inCnt}の6行目8行目10行目で解析分野が，この解析知能ハブに登録されていることがわかる．

\tabref{InputController}のInputDataメソッドではユーザーから入力があった時に入力された情報
を各解析分野の実装済みクラスに値を渡す．
その情報を用いて各解析知能ハブはそれぞれの解析分野にあった内容を解析する．
今回の場合は\tabref{InputController}の20行目で実際に各解析知能ハブの解析をおこなうメソッドを呼び出している．

%------------------------------------------------------%
%親の抽象クラス
%------------------------------------------------------%
\subsection{解析知能ハブ}
初めに解析知能ハブとは，感情解析知能ハブや話題解析知能ハブに当たるものであり，
各ハブはそれぞれ様々な解析アルゴリズムを所持しているものである．

解析する話題別にアルゴリズムを保持するために，Abstract Mode（以下親抽象クラス）という抽象クラスを
実装したこれが解析知能ハブの抽象クラスである．
親抽象クラスには解析する情報ごとに，プログラムを保持するための機構が記述されており
この親抽象クラスに実装した主要なメソッドなどを次の\tabref{Abstract Mode}に示す．

\begin{table}[tbh]
	\caption{Abstract Modeに実装した主要構成要素} \label{tab:Abstract Mode}
	\begin{center}
		\begin{tabular}[htb]{c|c}
		\hline
		init & 初期化を行うメソッド \\ \hline
		getAnalyzeParts　& 解析アルゴリズムを選択するメソッド \\ \hline
		analyzeChat & 入力があった際に解析を行わせるメソッド \\ \hline
		\end{tabular}
	\end{center}
\end{table}


\tabref{Abstract Mode}のinitメソッドでは各解析アルゴリズムが保持している話題
を，独自実装を行ったGoogleAPIに渡すことで頻出単語表を作成し，その検索結果の頻出単語表を取得している．

\tabref{Abstract Mode}のgetAnalyzePartsメソッドでは，実際に解析を行うアルゴリズムを生成された
頻出単語をもとに決めるメソッドである．
具体的には各解析アルゴリズムごとに生成された頻出単語表
\footnote{頻出単語表：検索結果の文字列から固有名詞だけをのこし，出現した単語とその数をカウントしたもの}
とユーザーが入力した文章をGoogleAPIを用いて作成した頻出単語表を比較して，
もっとも似ている頻出単語表を持つ解析アルゴリズムが，解析を行うという実装になっている．
%------------------------------------------------------%
%子の抽象クラス
%------------------------------------------------------%
\subsection{解析アルゴリズムの各解析知能ハブへの追加}\label{sec:anaAdd}
人工知能利用フレームワークの，解析アルゴリズムを簡単に実装する構成について説明する．
各解析知能ハブに対して，アルゴリズムを追加実装するために用いる，抽象クラス「Abstract Mode Parts」
(以下，子抽象クラス)を実装した．

この子抽象クラスには，親抽象クラスであるAbstract Modeを実装したクラスから解析する際に呼び出されるメソッドや
データベースなどとの連携が記述されている．
アルゴリズムを新規に追加し試したい場合，これらの部分については追記する必要がない点がメリットである．

以下の\tabref{Abstract Mode Parts}に実際に解析知能を作るために，必要な抽象クラスである
Abstract Mode Partsに実装した主要な要素を示す．

\begin{table}[tbh]
	\caption{Abstract Modeの主要構成要素} \label{tab:Abstract Mode Parts}
	\begin{center}
		\begin{tabular}[htb]{c|c}
		\hline
		クラス変数 & 保存を行うための変数が定義されている \\ \hline
		コンストラクタ　& アルゴリズムの分野を記述する場所 \\ \hline
		ChatAnalyze & アルゴリズムを記述する部分 \\ \hline
		saveData & 解析結果を保存 \\ \hline
		\end{tabular}
	\end{center}
\end{table}

\tabref{Abstract Mode Parts}のクラス変数は，解析した情報を保存するための変数である．
解析結果をクラス変数に入れることで，処理が終わった後に適切な形式でデータベースに自動で保存される．

\tabref{Abstract Mode Parts}のコンストラクタでは，その解析アルゴリズムの分野を記述する
必要性がある．
具体的にはaboutというString型の変数に話題を入れることで，
その話題をユーザーが話した時にそのアルゴリズムが選択されて返答されるという構造が実装される．
その部分のソースコードを一部抜粋したものを以下の\srcref{about}に示す．

\srcPst{Java}{about.java}{about}{コンストラクタで話題を設定するソースコードの一部}

\srcref{about}は料理に関する話題を解析するプログラムの，コンストラクタを抜粋したものだが，
ここで1行目のプログラムを記述する．

\tabref{Abstract Mode Parts}のChatAnalyzeは，実際に解析アルゴリズムを書く部分である．
ここで入力された内容が，String型で引数として渡されてくるのでその内容を用いて解析を行う．
解析した情報はあらかじめ定義してあるクラス変数に保存することで，自動でデータベースに格納されるようになっている．

\srcPst{Java}{anaAlgo.java}{anaAlgo}{解析アルゴリズムを記述するメソッドのソースコードの一部}

\srcref{anaAlgo}は解析を行うアルゴリズムを記述するメソッドのみを抜粋したもので，
ここでデータベースに保存する情報を解析し，解析した情報を変数に格納するプログラムを記述する．

次にデータを保存する際に用いるメソッドについて解説を行う為，継承元クラスのソースコードを一部抜粋したものを
以下の\srcref{anaParts}に示す．
\srcPst{Java}{anaParts.java}{anaParts}{継承元クラスから一部抜粋した定義済みのメソッド}

\srcref{anaParts}のsaveDataは，継承元のクラスに定義されているメソッドである．
このメソッドは全ての解析が終わった後に親抽象クラスから呼び出され，
変数の中に値が入っていた場合のみその内容をデータベースにそのクラス名＋データ型の名前をつけて保存する．
最後にこの抽象クラスを拡張して作成したクラスは，親クラスであるAbstract Modeを実装した
感情解析知能ハブや話題解析知能ハブなどの親抽象クラスに登録することでアルゴリズムの追加が完了する．

%------------------------------------------------------%
%現在実装しているアルゴリズム
%------------------------------------------------------%
\subsection{現在実装している解析アルゴリズム}
現在実装している解析プログラムは2種類あり，感情の解析と話題の解析である．
話題の解析に関しては例えばゲームの話題解析知能を作った場合，さらに細かい「どのゲームか」ということや
「どんなシーンなのか」などをさらに詳しく解析することを目的に作成した．

%------------------------------------------------------%
1つ目に感情の解析を行うアルゴリズムの実装について説明する．
感情の解析を行うプログラムは，親抽象クラスである感情解析知能ハブに所属する解析知能の1つである．
現在感情の解析を行うプログラムは1つなため，必ずこのアルゴリズムがデフォルト解析アルゴリズムとして，
選ばれるようになっている．

具体的な解析を行うアルゴリズムに関しては「哀れ」「恥」「怒り」「嫌」「怖い」「驚き」「好き」「高ぶり」「安らか」「喜び」
の10種類の感情に分類して感情の解析を行なっている．
このそれぞれの感情にはその感情に対応する単語が付いており，入力した文章の中にその単語があった時にその感情値
に1を加えて数字でその感情に関する文字列が出てきた回数を表現する仕組みになっている．

%------------------------------------------------------%
2つ目の話題を解析する知能では料理とゲームに関する話題を解析するプログラムが実装してあり，
料理の分野では「作る」「食べる」「片付ける」の3つの話題にさらに細かく解析する仕組みがある．
また，ゲームの分野では「戦闘」「負け」「勝利」の3つの話題にさらに細かく解析する仕組みを実装している．

%------------------------------------------------------%
%データベース実装
%------------------------------------------------------%

\section{データベースの実装}
\subsection{全ての解析情報を保存する機構}
まず初めにデータベースは独自実装したデータベースクラスを用いて実現した．
データベースの実装では様々な解析情報を保存する必要があるため，複数の変数型に対応するために，HashMap
のキーをStringにし，保存する値であるvalueをObject型に指定した．

このデータベースクラスにはデータを保存するためのメソッドが用意されており，以下にソースコードから
一部抜粋したものを示す．

\srcPst{Java}{dbIn.java}{dbIn}{データベースの解析結果を保存するメソッドの一部}

\srcref{dbIn}のsetDataメソッドは先ほどの\ref{sec:anaAdd}で説明したsaveDataメソッドから呼び出されて利用される．
保存を行う際にはデータの重複が起きないようにクラス名＋データの形式をデータに対応するキー
\footnote{データを取得する際に指定する文字列}としている．

\subsection{解析した情報を取得する機構}
解析した情報を取得する際はこのデータベースクラスのgetDataメソッドを呼び出す．
以下の\srcref{dbOut}にgetDataメソッドのソースコードを示す．

\srcPst{Java}{dbOut.java}{dbOut}{データベースの解析結果をするメソッド}

\srcref{dbOut}の2行目を見ると，データを取得する際にString型の鍵が必要であることがわかる．
このString型の鍵はデータベースの中にあるデータを保存しているHashMapの鍵を示しており，取得したい
情報の鍵をshowDataというメソッドを用いて情報を取得するための鍵を調べ，その鍵を用いて情報を取得する．

%------------------------------------------------------%
%OutputController
%------------------------------------------------------%

\section{出力を行う知能ハブの実装}
Unityへ命令の送信を行う部分の実装について説明する．

\subsection{出力コントローラー}
出力する情報をまとめ，JSON形式などを成形する出力コントローラーについて解説する．
出力コントローラーに，実装した主要な構成要素の一覧を以下の\tabref{OutputController}に示す．

\begin{table}[tbh]
	\caption{実装した主要な構成要素} \label{tab:OutputController}
	\begin{center}
		\begin{tabular}[htb]{c|c}
		\hline
		コンストラクタ & 各出力知能ハブを登録する \\
		\hline
		getJson & Unityへ出力情報を送るときに呼ばれるメソッド \\
		\hline
		getTimeAction & キャラクターが自発的に発言する際に用いられるメソッド \\
		\hline
		\end{tabular}
	\end{center}
\end{table}

\tabref{OutputController}のコンストラクタの部分では，各出力知能ハブをこのクラスに登録している．
登録された出力知能ハブはgetJsonメソッドが呼ばれたときに出力内容を作成するようになっている．

\tabref{OutputController}のgetJsonメソッドでは，Unityから入力があった際に呼ばれるメソッドであり，
あらかじめ登録されている出力知能ハブの，出力を作成するメソッドを呼び出す実装になっている．

\tabref{OutputController}のgetTimeActionメソッドでは，時間経過に応じてキャラクターが発言する
設定を有効にしているときに呼び出されるメソッドであり，このメソッドが呼ばれると各出力知能ハブの
自発的に発言する際に用いるメソッドを呼び出すことで応答を行う．

%------------------------------------------------------%
%出力知能はぶ Abstract_Mode
%------------------------------------------------------%
\subsection{出力知能ハブ}
出力する動作や返答内容といった出力情報別に，アルゴリズムを保持する機構について解説する．
この機構も情報解析の時と同じ仕組みで構成されており，
この出力の情報別に保持する機構についてもAbstact Modeという親抽象クラスが作成されている．
その抽象クラスを実装することで返答知能ハブや動作選択知能ハブといったアルゴリズムを複数所持するクラスを新規に作成することが可能である．

以下の\tabref{abstractmode}に出力知能ハブを作成するために必要な抽象クラスである
Abstract Modeの主要構成要素を示す．\\

\begin{table}[tbh]
	\caption{実装した主要な構成要素} \label{tab:abstractmode}
	\begin{center}
		\begin{tabular}[htb]{c|c}
		\hline
		init & 初期化 \\
		\hline
		getOutput & 返答内容の作成 \\
		\hline
		getTimerAction & キャラクターが自発的に発言する際に用いられるメソッド \\
		\hline
		\end{tabular}
	\end{center}
\end{table}

\tabref{abstractmode}のinitメソッドでは初期設定を行っており，独自実装をおこなったGoogleの検索結果データベースを
最新の情報に更新をする処理を行っている．

\tabref{abstractmode}のgetOutputメソッドでは，キャラクターにユーザーが話しかけてきたときに，返答内容を
作成するアルゴリズムから出力内容を取得し返答を行う．
返答するアルゴリズムを選択する機構もこの部分にあり，
アルゴリズムの選択はユーザーが発言した内容から作成した頻出単語表と各解析を実際に行う
アルゴリズムが持っている話題をもとに作成したHashMapを比較して，もっとも頻出単語表が似ているものを選ぶという仕組みになっている．
そのソースコードから一部抜粋したものを\srcref{getOutput}に示す．

\srcPst{Java}{getOutput.java}{getOutput}{getOutput.javaのソースコードの一部}

まず初めに，\srcref{getOutput}の8行，9行目で最新の発言情報を取得し，10行目で発言内容をGoogleAPIに
渡すことで頻出単語表を作成する．
次にあらかじめ作成してある各解析アルゴリズムごとの，話題単語の頻出単語表とGoogleAPIを用いて取得した頻出単語表を
11行目から25行目にかけて比較し，一番最適な解析アルゴリズムを選択している．
最後に45行目にて選択された解析アルゴリズムに解析を行わせ，解析結果をそのまま返している．

\tabref{abstractmode}のgetTimerActionメソッドは時間経過に応じて反応するときに呼び出され，
実際に出力内容を作成するアルゴリズムに対して，自発的に発言する際の出力内容を作成させて取得する．

\subsection{出力アルゴリズムの出力知能ハブへの追加}
実際に出力情報を作成するためのアルゴリズムを記述するプログラムを，簡単に出力知能ハブへ追加するために
出力専用のAbstract Mode Partsという子抽象クラスを作成した．
その抽象クラスを用いることで3行プログラムを書くだけで新しいアルゴリズムを追加できるようになっている．

それではまず初めに，その抽象クラスに実装した以下の\tabref{parts}に示した主要なメソッドについて解説する．

\begin{table}[tbh]
	\caption{実装した主要なメソッド} \label{tab:parts}
	\begin{center}
		\begin{tabular}[htb]{c|c}
		\hline
		コンストラクタ & 担当分野の設定 \\
		\hline
		Action & 返答アルゴリズムの \\
		\hline
		TimeAction & キャラクターが自発的に発言する際に用いられるメソッド \\
		\hline
		dataRefresh & 常にデータベースを最新に保つためのメソッド \\
		\hline
		\end{tabular}
	\end{center}
\end{table}

\tabref{parts}のコンストラクタでは，出力を行う際に担当する分野や話題について記述する部分である．
解析を行う際と同じように変数aboutに対して適切な担当する話題名を入れることで，GoogleAPIを用いて
その話題名に関する頻出単語表が自動で生成される．
その生成された頻出単語表も解析の時と同じく先ほど説明したアルゴリズムの選定に利用される．
以下の\srcref{aisatu}に挨拶の分野を指定する場合のプログラムを一部抜粋したものを示す．

\srcPst{Java}{aisatu.java}{aisatu}{話題を指定する際のサンプルソースコードの一部}

\srcref{aisatu}の3行目では話題を挨拶に指定しており，ユーザーが挨拶と関係のある単語を発話した時にこのアルゴリズムが
選択され，実際に返答内容を作成するようになるように実装されている．

\subsection{現在実装している出力アルゴリズム}\label{sec:back}
現在実装している出力知能ハブは2つあり，会話を行う知能ハブと動作選択を行う知能ハブの2種類である．
会話を行う知能ハブには2つのアルゴリズムが搭載されており，料理とゲームの話題に関するアルゴリズムを実装した．

料理のアルゴリズムでは，解析した時に取得した作る，食べる，片付けるの状態を用いて，返答を行う．

ゲームのアルゴリズムでは戦闘，負け，勝利の状態を解析しているのでそれを用いて返答を行っている．

次に動作を選択するアルゴリズムでは，共同開発の鈴木さんのデータベースから動作一覧とその1つ1つの動作に関係する単語，
及び関係する単語をGoogleAPIをもちいて頻出単語表を作ったものを取得する．

動作を選択するアルゴリズムはその動作に関連付けられている頻出単語表と，ユーザーの発言内容から作成した
頻出単語表を比較して，最も関連性のあるモーションを選択するようになっており，
その具体的なアルゴリズムや通信に関しては\ref{sec:motion}に記述する．
%------------------------------------------------------%
%Unityとの通信に関して
%------------------------------------------------------%

\section{Unityとの通信の実装}
\subsection{通信方式}
Unityとの通信にはWebSocketを用いており，双方向任意のタイミングでの情報の送受信が可能となっている．

Unityとの情報の送受信を行うために人工知能利用フレームワークの中に送受信を行うためのクラスである，
NewWSEndpointを実装した．
以下の\srcref{endpoint}にソースコードを一部抜粋したものを示す．

\srcPst{Java}{endpoint.java}{endpoint}{WebSocketのJavaサーバー側実装の一部}

\subsection{Unityからの入力情報の受信}
\srcref{endpoint}のソースコードではウェブブラウザ（Unityクライアント）が，
接続を行った時にそのセッションを保存する為に23行目でリストにセッションを格納している．
この実装により，セッションが確立され，受信を行う準備が完了する．

Unityからメッセージが来た場合は\srcref{endpoint}の44行目のprocessUploadが呼ばれる．
33行目には同じく受信するメソッドであるOnMessageというメソッドがあるが，
これはUnity上のキャラクター以外の端末からメッセージを受け取った際に呼ばれるものである．

processUploadメソッドではバイト形式で入力情報を受け取るため，47行目にてバイトをString型に変換している．
変換した後は48行目でその値を入力情報の解析を行う解析知能ハブへ渡している．
その処理が終わった後に49行目で返答するjson形式の出力情報を作成し，51行目で全ての接続クライアントに対して命令を送信している．

最後にこれ以上通信を行わない場合は\srcref{endpoint}の27行目で，セッションが切断された時にリストから削除する処理を行っている．

\subsection{Unityへの命令の送信}
\srcref{endpoint}の51行目で全ての接続クライアントに対して出力知能ハブから得たjson形式の値を
送信している．

人工知能利用フレームワークは家庭で利用されることを目標にしており，
例えばテレビのブラウザでキャラクターと対話，PCの画面でキャラクターと対話，スマホの画面でキャラクターと対話
を行った際に全てのデバイスから同じキャラクターと対話することを実現するために51行目では
全てのクライアントへ対して情報を送信するように実装をおこなった．

%------------------------------------------------------%
%データベースとの通信とモーションデータベースについて
%------------------------------------------------------%

\section{人工知能利用フレームワークに追加したモーションの利用}\label{sec:motion}
\subsection{動作選択アルゴリズムの実装}
先ほど\ref{sec:back}で説明した，動作選択を行う際に用いているアルゴリズムについて解説する．
以下に動作を選択する際に用いている動作選択アルゴリズムを一部抜粋したものを示す．

\srcPst{Java}{motion.java}{motion}{動作選択アルゴリズムの一部抜粋}

まず初めに，\srcref{motion}の3行目に動作選択が行われる際に呼び出される，Actionメソッドが記述されている，
このメソッドでは8行目に記述されたメソッドmatchを呼び出し，その中でキャラクターが行うモーションを選択している．
\srcref{motion}のmatchメソッドでは15行目から17行目にかけてデータベースを管理するコントローラーから
データベースの情報を取得している．
このコントローラーはサーバー上のMongoDBからモーションデータなどの情報を取得している．

また，このコントローラの実装に関しては共同開発の鈴木さんの論文\cite{suzuki}を参照すると，
このコントローラーからデータベースへの接続を行なっていることがわかる．

実際にどの動作を実行するかを判定しているアルゴリズムを解説する．
\srcref{motion}の22行目から39行目を見ると，
そこではユーザーが発言した内容から作成した頻出単語表と，データベースの中にあるモーションごとに関連付けられている頻出単語表を比較している．
その2つの頻出単語表を比較し，一番似ている頻出単語表を持っている動作が選択され，40行目でその動作名が返される仕組みとなっている．
%------------------------------------------------------%
%GoogleAPI
%------------------------------------------------------%
\section{GoogleAPIによる頻出単語表の作成}
今回実装したGoogleAPIでは，Google検索を用いてウェブ上から情報を取得する機能から
kuromojiを用いて形態素解析を行わせる機能，及び頻出単語表を作成する機能と3つの機能から成り立っている．

\subsection{形態素解析による検索ワードの作成}
ユーザーが入力した情報からどのような分野の単語なのかということを調べるにあたり，
その検索する際のキーワードというものは検索結果やアルゴリズムを選択する際の精度に関わるため，非常に重要である．

そこでJavaの形態素解析器であるkuromoji\cite{gitkuromoji}を用いて形態素解析を行い，
適切な検索ワードで検索を行えるようにmwSoft blog\cite{kuromoji}を参照，参考にしつつ実装を行った．

具体的にはkuromojiにはSearchモードというモードがあり，それを利用することで「今日の夕飯何にしよう」を
「今日 夕飯 何 しよ」のように検索で利用しやすい形に分解することが可能である．
このように入力を行った情報をそのまま検索するのではなく，形態素解析を行ってから検索を行うことで
より良い検索結果を取得できると考えられる．

\subsection{GoogleAPIを利用して検索結果を取得}
検索をかける際にはHttpClientを用いて検索を行っている，HttpClientはPOST通信を用いてサーバーへ接続を
行い，XML形式で結果を受け取るもので，これを用いることでgoogleの検索結果をそのまま文字として取得することが可能である．
この機構を実現するためにmwSoft blog\cite{google}を参考にし，これに加えて並列初期化機能などの複数の機能を独自実装した．

以下の\srcref{google}に実装を行ったGoogleAPIのソースを一部抜粋したものを記載する．
\srcPst{Java}{google.java}{google}{GoogleAPIの一部抜粋ソースコード}

\srcref{google}の20行目にてgoogleの検索結果ページのURLを作成し，通信することでGoogle検索の結果の内容を取得している．

\srcref{google}の23行目から37行目にかけて検索キーワードを作成しており，先ほど説明したkuromojiの
検索しやすい単語ごとに区切るSearchモードの機能だけではなく，今回は助詞と助動詞を検索ワードから排除して検索を行っている．

\srcref{google}の47行目では実際にウェブサイト上から情報を取得しており，取得した結果を
GoogleSerchResultAnalyzerクラスを用いて解析を行い，リストに格納している．

\subsection{検索結果のフィルタリング}
検索結果にはどの単語を検索しても必ず含まれる単語が複数ある．
例としては「キャッシュ」といった検索を行った際に表示される文字列や「類似」という単語である．
これらの単語は頻出単語表を作成する上で不要なため，フィルタリングを行っており実際にフィルタリングを行っているのは
\srcref{google}の84行目から108行目である．
84行目から行われているのは記号を取り除く作業であり，頻出単語とはなりえない記号を取り除いている．

\subsection{頻出単語表の作成}
頻出単語表を作成するにあたって独自にWordCounterというクラスを実装した．
以下にWordCounterから一部抜粋したソースコードを記載する．

\srcPst{Java}{word.java}{word}{WordCounterの一部抜粋ソースコード}

\srcref{word}の7行目に定義されているwordcountというメソッドに対して，単語ごとにカウントを行って欲しい
文字列を渡すことで解析を行うことが可能である．
引数としてはborderを設定することができ，1回しか出てこない単語に関してはカウントを行わないという設定を行うことが可能である．

初めにカウントを行うにあたって，入力された文章を形態素解析にかける必要があるため，実装では
\srcref{word}の11行目にてkuromojiを用いた形態素解析を行なっている．
次に形態素解析を行った文章に出てくる単語をカウントする部分については，\srcref{word}の14行目から24行目にて
行っている．
最後にカウントした結果をHashMap形式にし，41行目でそのHashMapを返していることがわかる．
以下の\srcref{words}に例として「今日の夕飯何にしよう」で検索を行った結果をもとに作成した頻出単語表を記述する．

\srcPst{Java}{words.json}{words}{頻出単語表}

\srcref{words}の頻出単語表を見ると国名が多く，その国々の料理の検索結果を取得していることがわかる．
例えば日という単語であれば日＝5の様に表記されており，日という単語が5回出てきたことがわかる．
また，そのほかにも料理のレシピを検索することが可能なウェブサービスであるクックパッドのクックの文字を多く取得しているほか，
調味料の名前であるキッコーマンなどの単語も取得することが可能である．

以上の様に検索結果からその検索した単語と同じ様な意味を持つ単語を取得することが可能である．
